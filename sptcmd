#!/bin/bash
# simple pt trace a command

usage() {
	cat <<EOU
Simple PT processor branch trace. The complete system is traced
unless a comm filter is set, as long as cmd is executing.
The output files are in ptout.CPU and ptout.sideband

When cmd has options please use -- to separate them from the sptcmd options.

sptcmd [options] cmd
-c COMM  Set comm filter for comm (only trace that command)
-K disable kernel trace (default on)
-U disable user trace (default on)
-t enable msr trace in side band
-R disable return compression
-d Always reload driver
-N Don't dump data
-o PREFIX Dump to PREFIX.cpu and PREFIX.sideband (default ptout)
-e enumerate all processes in sideband (default unless -c is set)

Following flags are not supported on Broadwell:

-C thresh Set cycle packet threshold to 2^(n-1) cycles for fine grained timing
-M freq	  Set MTC packet threshold to 2^(n-1)
-P freq	  Set PSB packet threshold to 2K^n bytes
-F start,end  Only trace between virtual address start-end. Can be kernel symbols.
	      Two ranges allowed (shared with -S)
-S start,end  Stop trace when reaching virtual address start-end. Can be kernel
	      symbols. Two ranges allowed (shared with -F)
-s start      Start trace on CPU when kernel symbol start is hit. Can be address              or sym+offset
-y stop	      Stop trace on CPU when kernel symbol stop is hit. Can be address
              or sym+offset
EOU
}

unset COMM KERNEL TRACE USERMODE DISRETC DRIVER DONTDUMP PREFIX ENUMALL
unset CYC_THRESH MTC_FREQ PSB_FREQ FILTER TSTOP START STOP
declare -a RANGE_START RANGE_END
NUM_RANGE=0
ENUMDFL=1

while getopts "c:KtURdNo:eC:M:P:F:S:s:y:" opt ; do
	case "$opt" in
	c) COMM="$OPTARG" ; ENUMDFL=0 ;;
	K) KERNEL=0 ;;
	t) TRACE=1 ;;
	U) USERMODE=0 ;;
	R) DISRETC=1 ;;
	d) DRIVER=1 ;;
	N) DONTDUMP=1 ;;
	o) PREFIX="$OPTARG" ;;
	e) ENUMALL=1 ;;
	C) CYC_THRESH="$OPTARG" ;;
	M) MTC_FREQ="$OPTARG" ;;
	P) PSB_FREQ="$OPTARG" ;;
	F) IFS=, read st end <<< "$OPTARG"
	   RANGE_START[$NUM_RANGE]=$st
	   RANGE_END[$NUM_RANGE]=$end
	   RANGE_CFG[$NUM_RANGE]=1
	   (( NUM_RANGE++ ))
	   ;;
	S) IFS=, read st end <<< "$OPTARG"
	   RANGE_START[$NUM_RANGE]=$st
	   RANGE_END[$NUM_RANGE]=$end
	   RANGE_CFG[$NUM_RANGE]=2
	   (( NUM_RANGE++ ))
	   ;;
	s) START="$OPTARG" ;;
	y) STOP="$OPTARG" ;;
	\?) usage ; exit 1 ;;
	*) break ;;
	esac
done
shift $((OPTIND - 1))

COMM=${COMM:-}
KERNEL=${KERNEL:-1}
TRACE=${TRACE:-0}
USERMODE=${USERMODE:-1}
DISRETC=${DISRETC:-0}
DRIVER=${DRIVER:-}
DONTDUMP=${DONTDUMP:-}
PREFIX=${PREFIX:-ptout}
ENUMALL=${ENUMALL:-$ENUMDFL}
CYC_THRESH=${CYC_THRESH:-0}
MTC_FREQ=${MTC_FREQ:-0}
PSB_FREQ=${PSB_FREQ:-0}
START=${START:-}
STOP=${STOP:-}

if [ "$KERNEL" != 1 -a "$COMM" = "" ] ; then
	echo >&2 WARNING Using -K without a -c filter.
	echo >&2 WARNING Decoder will not be able to trace multiple processes.
fi

PATH=$PATH:$(dirname $0)

[ -n "$DRIVER" ] && /sbin/rmmod simple_pt
if ! lsmod | grep -q simple_pt ; then
	if [ -r simple-pt.ko ] ; then
		/sbin/insmod simple-pt.ko
	else
		/sbin/modprobe simple-pt
	fi
fi
C=/sys/module/simple_pt/parameters
if [ -n "$COMM" ] ; then
	echo $COMM > $C/comm_filter
	echo 1 > $C/cr3_filter
fi
echo $KERNEL > $C/kernel
echo $USERMODE > $C/user
echo $DISRETC > $C/dis_retc
T=/sys/kernel/debug/tracing
echo $TRACE > $T/events/pttp/msr/enable
echo 1 > $T/events/pttp/exec_cr3/enable
echo 1 > $T/events/pttp/mmap_cr3/enable
echo 1 > $T/events/pttp/process_cr3/enable
echo $MTC_FREQ > $C/mtc_freq
echo $CYC_THRESH > $C/cyc_thresh
echo $PSB_FREQ > $C/psb_freq
for (( r = 0; r < NUM_RANGE; r++ )) ; do
	echo $RANGE_START[$r] > $C/addr${r}_start
	echo $RANGE_END[$r] > $C/addr${r}_end
	echo $RANGE_CFG[$r] > $C/addr${r}_cfg
done
if [ "$START" != "" ] ; then
	echo $START > $C/trace_start
fi
if [ "$STOP" != "" ] ; then
	echo $STOP > $C/trace_stop
fi
echo > $T/trace
echo $ENUMALL > $C/enumerate_all
if [ "$ENUMALL" != 0 ] ; then
	grep . /proc/[0-9]*/maps > ${PREFIX}.maps
	echo "Wrote initial process maps to ${PREFIX}.maps"
fi
echo 1 > $C/start
"$@"
echo 0 > $C/start
echo 0 > $T/events/pttp/exec_cr3/enable
echo 0 > $T/events/pttp/mmap_cr3/enable
echo 0 > $T/events/pttp/process_cr3/enable
echo 0 > $T/events/pttp/msr/enable
if [ -z "$DONTDUMP" ] ; then
	sptdump $PREFIX

	sptsideband.py $T/trace ${PREFIX}.maps > ${PREFIX}.sideband

	#if [ -r /boot/vmlinux-$(uname -r) ] ; then
	#	echo -e "0.0 0 0 0\t/boot/vmlinux-$(uname -r)" >> ${PREFIX}.sideband
	#elif [ -r /lib/modules/$(uname -r)/build/vmlinux ] ; then
	#	echo -e "0.0 0 0 0\t/lib/modules/$(uname -r)/build/vmlinux" >> ${PREFIX}.sideband
	#else
	#	echo "vmlinux not found"
	#fi

	#shopt -s globstar
	#while read name a b c d addr ; do
	#	name=$(echo $name | sed s/_/?/g)
	#	echo -e "0.0 0" $addr 0 "\t" /lib/modules/$(uname -r)/**/${name}.ko
	#done < /proc/modules >> ${PREFIX}.sideband
	echo "Wrote sideband to ${PREFIX}.sideband"
fi
